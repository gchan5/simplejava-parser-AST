//TEAM MEMBERS: GILBERT CHAN, JOSEPH PEREZ

options {
  IGNORE_CASE=false;
}

PARSER_BEGIN(simplejava)

public class simplejava {
}


PARSER_END(simplejava)

TOKEN_MGR_DECLS :
{
    public static int numcomments = 0;
}

SKIP :
{
    < "//" > : INLINE_COMMENT
|   < " " >
|   < "\n" >
|   < "\t" >
|   < "\r" >
}

SKIP :
{
< "/*" > {numcomments++;}: IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SKIP :
{
    < " " >
|   < "/*"> {numcomments++;}
|   < "*/" > {numcomments--; if(numcomments == 0) SwitchTo(DEFAULT);}
|   < ~[] >
}

<INLINE_COMMENT>
SKIP :
{
    <"\n"> : DEFAULT
|   < ~[] >
}

TOKEN :
{
    <INTEGER_LITERAL: (["0"-"9"])+>
|   < DO: "do">
|   < ELSE: "else">
|   < FALSE: "false">
|   < FOR: "for">
|   < IF: "if">
|   < TRUE: "true">
|   < WHILE: "while">
|   < RETURN: "return">
|   < PLUS_EQUALS: "+=">
|   < NOT_EQUALS: "!=">
|   < EQUALS_EQUALS: "==">
|   < LESS_THAN_EQUAL_TO: "<=">
|   < GREATER_THAN_EQUAL_TO: ">=">
|   < PLUS_PLUS: "++">
|   < MINUS_MINUS: "--">
|   < AND: "&&">
|   < OR: "||">
|   <NEW: "new">
|   <IDENTIFIER: ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z","0"-"9", "_"])*>
}

TOKEN :
{
    < EQUALS: "=" >
|   < PLUS: "+" >
|   < MINUS: "-" >
|   < ASTERISK: "*" >
|   < SLASH: "/" >
|   < LEFT_PARENTHESIS: "(">
|   < RIGHT_PARENTHESIS: ")">
|   < LEFT_BRACE: "{">
|   < RIGHT_BRACE: "}">
|   < LEFT_BRACKET: "[">
|   < RIGHT_BRACKET: "]">
|   < PERIOD: ".">
|   < COMMA: ",">
|   < SEMICOLON: ";">
|   < LESS_THAN: "<">
|   < GREATER_THAN: ">">
|   < NOT: "!">
}

// Matches the three kinds of overhead structures
//      Function definition
//      Function prototype
//      Class definition
ASTProgram program():
{ASTFunction main; ASTFunctionDefinitions f = new ASTFunctionDefinitions();}
{
    main = main_func() {f.addElement(main);}
    {return new ASTProgram(new ASTClasses(), f, 0);}
    <EOF>
}

// Matches the functions of form <ID> <ID> params() block()
ASTFunction main_func():
{
    ASTFunction result;
    ASTStatement statement;
    String type;
    String name;
}
{
    type = <IDENTIFIER>.image name = <IDENTIFIER>.image
    <LEFT_PARENTHESIS><RIGHT_PARENTHESIS>
    <LEFT_BRACE> statement = statements()
        {return new ASTFunction(type, name, new ASTFormals(), statement, 0);}
}

// Matches any kind of statement:
//      generic variable definitions
//      generic variable assignments
//      if-else, for
//      while, do-while
//      return
ASTStatements statements():
{ASTStatements s = new ASTStatements(); ASTStatement statement;}
{
    (statement = var_statement() {s.addElement(statement);})*
    <RIGHT_BRACE> {return s;}
}

// Matches any kind of statement that is
//       not a for, if-else, while, do-while, or return
ASTStatement var_statement():
{
    ASTStatement statement;
    ASTBaseVariable variable;
    String name = "";
    String type = "";
    int arraydimension = 0;
    ASTExpression init = null;
    boolean isDefinition = false;
    boolean isArrayExpression = false;
}
{
    
    (LOOKAHEAD(2) type = <IDENTIFIER>.image name = <IDENTIFIER>.image (arraydimension = dimension_consumer() {isArrayExpression = true;})? {isDefinition = true;}
    | name = <IDENTIFIER>.image)

    (<SEMICOLON> | <EQUALS> init = expression() <SEMICOLON>)
    
    
    {   if(isDefinition){
            if (isArrayExpression){
                return new ASTVariableDefStatement(type, name, arraydimension, 0);
            }else{
                return new ASTVariableDefStatement(type, name, 0);
            }
        }else{
            return new ASTAssignmentStatement(new ASTBaseVariable(name, 0), init, 0);
        }
    }

    // ASTAssignmentStatement(ASTVariable variable, ASTExpression value, int line)
    // ASTVariableDefStatement(String type, String name, int arraydimension, ASTExpression init, int line)
}

// Matches and returns number of '[]'s
int dimension_consumer():
{int arraydimension = 0;}
{
    (<LEFT_BRACKET><RIGHT_BRACKET>{arraydimension++;})+
    {return arraydimension;}
}


// Matches any expression
// var
// number
// (expression)
// expression && || expression
// expression +- expression
// expression */ expression
ASTExpression expression():
{
    ASTExpression init;
    String var;
}
{
    <LEFT_PARENTHESIS> init = expression() <RIGHT_PARENTHESIS> {return init;}

|   LOOKAHEAD(2) init = new_expression() {return init;} //Idk why this was complaining. I used a <NEW> token afterall..


|   var = <INTEGER_LITERAL>.image (init = complex(); return init;)? {init = (ASTExpression) new ASTIntegerLiteral(Integer.parseInt(var), 0); return init;}



|   var = <IDENTIFIER>.image {init = (ASTExpression) new ASTVariableExpression(new ASTBaseVariable(var, 0), 0); return init;}
}

ASTExpression complex(ASTVariable base):
{ASTExpression complex}
{

    <LEFT_BRACKET> expression() <RIGHT_BRACKET>

    <PERIOD> expression()


    // ASTArrayVariable(ASTVariable base, ASTExpression index, int line)
    // ASTClassVariable(ASTVariable base, String variable, int line)
}




// Goes to either new_array_instance() or new_class_instance()
// ex:  new int[][][]
//      new Object(2, 3)
ASTExpression new_expression():
{
    ASTExpression expression;
    String type;
}
{
    <NEW> type = <IDENTIFIER>.image (expression = new_array_instance(type) | expression = new_class_instance(type)) {return expression;}
}

// new <ID> <LEFT_BRACKET>
ASTNewArrayExpression new_array_instance(String type):
{
    String element;
    int arraydimension = 1;
    int line = 0;
}
{
    <LEFT_BRACKET> element = <INTEGER_LITERAL>.image <RIGHT_BRACKET> (arraydimension = dimension_consumer() {arraydimension++;})?
    {
        return new ASTNewArrayExpression(type, new ASTIntegerLiteral(Integer.parseInt(element), line), arraydimension, line);
    }
}

// new <ID> <LEFT_PARENTHESIS>
ASTNewArrayExpression new_class_instance(String type):
{
    String element;
    int arraydimension = 1;
    int line = 0;
}
{
     <LEFT_PARENTHESIS> element = <INTEGER_LITERAL>.image <RIGHT_PARENTHESIS>
    {
        return new ASTNewArrayExpression(type, new ASTIntegerLiteral(Integer.parseInt(element), line), arraydimension, line);
    }
}

